// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package repositories

import (
	"context"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"github.com/pablor21/goms/app/models"
)

func newAssetFolder(db *gorm.DB, opts ...gen.DOOption) assetFolder {
	_assetFolder := assetFolder{}

	_assetFolder.assetFolderDo.UseDB(db, opts...)
	_assetFolder.assetFolderDo.UseModel(&models.AssetFolder{})

	tableName := _assetFolder.assetFolderDo.TableName()
	_assetFolder.ALL = field.NewAsterisk(tableName)
	_assetFolder.ID = field.NewInt64(tableName, "id")
	_assetFolder.CreatedAt = field.NewTime(tableName, "created_at")
	_assetFolder.UpdatedAt = field.NewTime(tableName, "updated_at")
	_assetFolder.Metadata = field.NewField(tableName, "metadata")
	_assetFolder.LibraryID = field.NewInt64(tableName, "library_id")
	_assetFolder.Name = field.NewString(tableName, "name")
	_assetFolder.Description = field.NewString(tableName, "description")
	_assetFolder.ParentID = field.NewInt64(tableName, "parent_id")
	_assetFolder.Path = field.NewString(tableName, "path")
	_assetFolder.Children = assetFolderHasManyChildren{
		db: db.Session(&gorm.Session{}),

		RelationField: field.NewRelation("Children", "models.AssetFolder"),
		Library: struct {
			field.RelationField
			RootFolder struct {
				field.RelationField
			}
		}{
			RelationField: field.NewRelation("Children.Library", "models.AssetLibrary"),
			RootFolder: struct {
				field.RelationField
			}{
				RelationField: field.NewRelation("Children.Library.RootFolder", "models.AssetFolder"),
			},
		},
		Parent: struct {
			field.RelationField
		}{
			RelationField: field.NewRelation("Children.Parent", "models.AssetFolder"),
		},
		Children: struct {
			field.RelationField
		}{
			RelationField: field.NewRelation("Children.Children", "models.AssetFolder"),
		},
	}

	_assetFolder.Library = assetFolderBelongsToLibrary{
		db: db.Session(&gorm.Session{}),

		RelationField: field.NewRelation("Library", "models.AssetLibrary"),
	}

	_assetFolder.Parent = assetFolderBelongsToParent{
		db: db.Session(&gorm.Session{}),

		RelationField: field.NewRelation("Parent", "models.AssetFolder"),
	}

	_assetFolder.fillFieldMap()

	return _assetFolder
}

type assetFolder struct {
	assetFolderDo

	ALL         field.Asterisk
	ID          field.Int64
	CreatedAt   field.Time
	UpdatedAt   field.Time
	Metadata    field.Field
	LibraryID   field.Int64
	Name        field.String
	Description field.String
	ParentID    field.Int64
	Path        field.String
	Children    assetFolderHasManyChildren

	Library assetFolderBelongsToLibrary

	Parent assetFolderBelongsToParent

	fieldMap map[string]field.Expr
}

func (a assetFolder) Table(newTableName string) *assetFolder {
	a.assetFolderDo.UseTable(newTableName)
	return a.updateTableName(newTableName)
}

func (a assetFolder) As(alias string) *assetFolder {
	a.assetFolderDo.DO = *(a.assetFolderDo.As(alias).(*gen.DO))
	return a.updateTableName(alias)
}

func (a *assetFolder) updateTableName(table string) *assetFolder {
	a.ALL = field.NewAsterisk(table)
	a.ID = field.NewInt64(table, "id")
	a.CreatedAt = field.NewTime(table, "created_at")
	a.UpdatedAt = field.NewTime(table, "updated_at")
	a.Metadata = field.NewField(table, "metadata")
	a.LibraryID = field.NewInt64(table, "library_id")
	a.Name = field.NewString(table, "name")
	a.Description = field.NewString(table, "description")
	a.ParentID = field.NewInt64(table, "parent_id")
	a.Path = field.NewString(table, "path")

	a.fillFieldMap()

	return a
}

func (a *assetFolder) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := a.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (a *assetFolder) fillFieldMap() {
	a.fieldMap = make(map[string]field.Expr, 12)
	a.fieldMap["id"] = a.ID
	a.fieldMap["created_at"] = a.CreatedAt
	a.fieldMap["updated_at"] = a.UpdatedAt
	a.fieldMap["metadata"] = a.Metadata
	a.fieldMap["library_id"] = a.LibraryID
	a.fieldMap["name"] = a.Name
	a.fieldMap["description"] = a.Description
	a.fieldMap["parent_id"] = a.ParentID
	a.fieldMap["path"] = a.Path

}

func (a assetFolder) clone(db *gorm.DB) assetFolder {
	a.assetFolderDo.ReplaceConnPool(db.Statement.ConnPool)
	return a
}

func (a assetFolder) replaceDB(db *gorm.DB) assetFolder {
	a.assetFolderDo.ReplaceDB(db)
	return a
}

type assetFolderHasManyChildren struct {
	db *gorm.DB

	field.RelationField

	Library struct {
		field.RelationField
		RootFolder struct {
			field.RelationField
		}
	}
	Parent struct {
		field.RelationField
	}
	Children struct {
		field.RelationField
	}
}

func (a assetFolderHasManyChildren) Where(conds ...field.Expr) *assetFolderHasManyChildren {
	if len(conds) == 0 {
		return &a
	}

	exprs := make([]clause.Expression, 0, len(conds))
	for _, cond := range conds {
		exprs = append(exprs, cond.BeCond().(clause.Expression))
	}
	a.db = a.db.Clauses(clause.Where{Exprs: exprs})
	return &a
}

func (a assetFolderHasManyChildren) WithContext(ctx context.Context) *assetFolderHasManyChildren {
	a.db = a.db.WithContext(ctx)
	return &a
}

func (a assetFolderHasManyChildren) Session(session *gorm.Session) *assetFolderHasManyChildren {
	a.db = a.db.Session(session)
	return &a
}

func (a assetFolderHasManyChildren) Model(m *models.AssetFolder) *assetFolderHasManyChildrenTx {
	return &assetFolderHasManyChildrenTx{a.db.Model(m).Association(a.Name())}
}

type assetFolderHasManyChildrenTx struct{ tx *gorm.Association }

func (a assetFolderHasManyChildrenTx) Find() (result []*models.AssetFolder, err error) {
	return result, a.tx.Find(&result)
}

func (a assetFolderHasManyChildrenTx) Append(values ...*models.AssetFolder) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Append(targetValues...)
}

func (a assetFolderHasManyChildrenTx) Replace(values ...*models.AssetFolder) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Replace(targetValues...)
}

func (a assetFolderHasManyChildrenTx) Delete(values ...*models.AssetFolder) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Delete(targetValues...)
}

func (a assetFolderHasManyChildrenTx) Clear() error {
	return a.tx.Clear()
}

func (a assetFolderHasManyChildrenTx) Count() int64 {
	return a.tx.Count()
}

type assetFolderBelongsToLibrary struct {
	db *gorm.DB

	field.RelationField
}

func (a assetFolderBelongsToLibrary) Where(conds ...field.Expr) *assetFolderBelongsToLibrary {
	if len(conds) == 0 {
		return &a
	}

	exprs := make([]clause.Expression, 0, len(conds))
	for _, cond := range conds {
		exprs = append(exprs, cond.BeCond().(clause.Expression))
	}
	a.db = a.db.Clauses(clause.Where{Exprs: exprs})
	return &a
}

func (a assetFolderBelongsToLibrary) WithContext(ctx context.Context) *assetFolderBelongsToLibrary {
	a.db = a.db.WithContext(ctx)
	return &a
}

func (a assetFolderBelongsToLibrary) Session(session *gorm.Session) *assetFolderBelongsToLibrary {
	a.db = a.db.Session(session)
	return &a
}

func (a assetFolderBelongsToLibrary) Model(m *models.AssetFolder) *assetFolderBelongsToLibraryTx {
	return &assetFolderBelongsToLibraryTx{a.db.Model(m).Association(a.Name())}
}

type assetFolderBelongsToLibraryTx struct{ tx *gorm.Association }

func (a assetFolderBelongsToLibraryTx) Find() (result *models.AssetLibrary, err error) {
	return result, a.tx.Find(&result)
}

func (a assetFolderBelongsToLibraryTx) Append(values ...*models.AssetLibrary) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Append(targetValues...)
}

func (a assetFolderBelongsToLibraryTx) Replace(values ...*models.AssetLibrary) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Replace(targetValues...)
}

func (a assetFolderBelongsToLibraryTx) Delete(values ...*models.AssetLibrary) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Delete(targetValues...)
}

func (a assetFolderBelongsToLibraryTx) Clear() error {
	return a.tx.Clear()
}

func (a assetFolderBelongsToLibraryTx) Count() int64 {
	return a.tx.Count()
}

type assetFolderBelongsToParent struct {
	db *gorm.DB

	field.RelationField
}

func (a assetFolderBelongsToParent) Where(conds ...field.Expr) *assetFolderBelongsToParent {
	if len(conds) == 0 {
		return &a
	}

	exprs := make([]clause.Expression, 0, len(conds))
	for _, cond := range conds {
		exprs = append(exprs, cond.BeCond().(clause.Expression))
	}
	a.db = a.db.Clauses(clause.Where{Exprs: exprs})
	return &a
}

func (a assetFolderBelongsToParent) WithContext(ctx context.Context) *assetFolderBelongsToParent {
	a.db = a.db.WithContext(ctx)
	return &a
}

func (a assetFolderBelongsToParent) Session(session *gorm.Session) *assetFolderBelongsToParent {
	a.db = a.db.Session(session)
	return &a
}

func (a assetFolderBelongsToParent) Model(m *models.AssetFolder) *assetFolderBelongsToParentTx {
	return &assetFolderBelongsToParentTx{a.db.Model(m).Association(a.Name())}
}

type assetFolderBelongsToParentTx struct{ tx *gorm.Association }

func (a assetFolderBelongsToParentTx) Find() (result *models.AssetFolder, err error) {
	return result, a.tx.Find(&result)
}

func (a assetFolderBelongsToParentTx) Append(values ...*models.AssetFolder) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Append(targetValues...)
}

func (a assetFolderBelongsToParentTx) Replace(values ...*models.AssetFolder) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Replace(targetValues...)
}

func (a assetFolderBelongsToParentTx) Delete(values ...*models.AssetFolder) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Delete(targetValues...)
}

func (a assetFolderBelongsToParentTx) Clear() error {
	return a.tx.Clear()
}

func (a assetFolderBelongsToParentTx) Count() int64 {
	return a.tx.Count()
}

type assetFolderDo struct{ gen.DO }

type IAssetFolderDo interface {
	gen.SubQuery
	Debug() IAssetFolderDo
	WithContext(ctx context.Context) IAssetFolderDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() IAssetFolderDo
	WriteDB() IAssetFolderDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) IAssetFolderDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) IAssetFolderDo
	Not(conds ...gen.Condition) IAssetFolderDo
	Or(conds ...gen.Condition) IAssetFolderDo
	Select(conds ...field.Expr) IAssetFolderDo
	Where(conds ...gen.Condition) IAssetFolderDo
	Order(conds ...field.Expr) IAssetFolderDo
	Distinct(cols ...field.Expr) IAssetFolderDo
	Omit(cols ...field.Expr) IAssetFolderDo
	Join(table schema.Tabler, on ...field.Expr) IAssetFolderDo
	LeftJoin(table schema.Tabler, on ...field.Expr) IAssetFolderDo
	RightJoin(table schema.Tabler, on ...field.Expr) IAssetFolderDo
	Group(cols ...field.Expr) IAssetFolderDo
	Having(conds ...gen.Condition) IAssetFolderDo
	Limit(limit int) IAssetFolderDo
	Offset(offset int) IAssetFolderDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) IAssetFolderDo
	Unscoped() IAssetFolderDo
	Create(values ...*models.AssetFolder) error
	CreateInBatches(values []*models.AssetFolder, batchSize int) error
	Save(values ...*models.AssetFolder) error
	First() (*models.AssetFolder, error)
	Take() (*models.AssetFolder, error)
	Last() (*models.AssetFolder, error)
	Find() ([]*models.AssetFolder, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*models.AssetFolder, err error)
	FindInBatches(result *[]*models.AssetFolder, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*models.AssetFolder) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) IAssetFolderDo
	Assign(attrs ...field.AssignExpr) IAssetFolderDo
	Joins(fields ...field.RelationField) IAssetFolderDo
	Preload(fields ...field.RelationField) IAssetFolderDo
	FirstOrInit() (*models.AssetFolder, error)
	FirstOrCreate() (*models.AssetFolder, error)
	FindByPage(offset int, limit int) (result []*models.AssetFolder, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) IAssetFolderDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (a assetFolderDo) Debug() IAssetFolderDo {
	return a.withDO(a.DO.Debug())
}

func (a assetFolderDo) WithContext(ctx context.Context) IAssetFolderDo {
	return a.withDO(a.DO.WithContext(ctx))
}

func (a assetFolderDo) ReadDB() IAssetFolderDo {
	return a.Clauses(dbresolver.Read)
}

func (a assetFolderDo) WriteDB() IAssetFolderDo {
	return a.Clauses(dbresolver.Write)
}

func (a assetFolderDo) Session(config *gorm.Session) IAssetFolderDo {
	return a.withDO(a.DO.Session(config))
}

func (a assetFolderDo) Clauses(conds ...clause.Expression) IAssetFolderDo {
	return a.withDO(a.DO.Clauses(conds...))
}

func (a assetFolderDo) Returning(value interface{}, columns ...string) IAssetFolderDo {
	return a.withDO(a.DO.Returning(value, columns...))
}

func (a assetFolderDo) Not(conds ...gen.Condition) IAssetFolderDo {
	return a.withDO(a.DO.Not(conds...))
}

func (a assetFolderDo) Or(conds ...gen.Condition) IAssetFolderDo {
	return a.withDO(a.DO.Or(conds...))
}

func (a assetFolderDo) Select(conds ...field.Expr) IAssetFolderDo {
	return a.withDO(a.DO.Select(conds...))
}

func (a assetFolderDo) Where(conds ...gen.Condition) IAssetFolderDo {
	return a.withDO(a.DO.Where(conds...))
}

func (a assetFolderDo) Order(conds ...field.Expr) IAssetFolderDo {
	return a.withDO(a.DO.Order(conds...))
}

func (a assetFolderDo) Distinct(cols ...field.Expr) IAssetFolderDo {
	return a.withDO(a.DO.Distinct(cols...))
}

func (a assetFolderDo) Omit(cols ...field.Expr) IAssetFolderDo {
	return a.withDO(a.DO.Omit(cols...))
}

func (a assetFolderDo) Join(table schema.Tabler, on ...field.Expr) IAssetFolderDo {
	return a.withDO(a.DO.Join(table, on...))
}

func (a assetFolderDo) LeftJoin(table schema.Tabler, on ...field.Expr) IAssetFolderDo {
	return a.withDO(a.DO.LeftJoin(table, on...))
}

func (a assetFolderDo) RightJoin(table schema.Tabler, on ...field.Expr) IAssetFolderDo {
	return a.withDO(a.DO.RightJoin(table, on...))
}

func (a assetFolderDo) Group(cols ...field.Expr) IAssetFolderDo {
	return a.withDO(a.DO.Group(cols...))
}

func (a assetFolderDo) Having(conds ...gen.Condition) IAssetFolderDo {
	return a.withDO(a.DO.Having(conds...))
}

func (a assetFolderDo) Limit(limit int) IAssetFolderDo {
	return a.withDO(a.DO.Limit(limit))
}

func (a assetFolderDo) Offset(offset int) IAssetFolderDo {
	return a.withDO(a.DO.Offset(offset))
}

func (a assetFolderDo) Scopes(funcs ...func(gen.Dao) gen.Dao) IAssetFolderDo {
	return a.withDO(a.DO.Scopes(funcs...))
}

func (a assetFolderDo) Unscoped() IAssetFolderDo {
	return a.withDO(a.DO.Unscoped())
}

func (a assetFolderDo) Create(values ...*models.AssetFolder) error {
	if len(values) == 0 {
		return nil
	}
	return a.DO.Create(values)
}

func (a assetFolderDo) CreateInBatches(values []*models.AssetFolder, batchSize int) error {
	return a.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (a assetFolderDo) Save(values ...*models.AssetFolder) error {
	if len(values) == 0 {
		return nil
	}
	return a.DO.Save(values)
}

func (a assetFolderDo) First() (*models.AssetFolder, error) {
	if result, err := a.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*models.AssetFolder), nil
	}
}

func (a assetFolderDo) Take() (*models.AssetFolder, error) {
	if result, err := a.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*models.AssetFolder), nil
	}
}

func (a assetFolderDo) Last() (*models.AssetFolder, error) {
	if result, err := a.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*models.AssetFolder), nil
	}
}

func (a assetFolderDo) Find() ([]*models.AssetFolder, error) {
	result, err := a.DO.Find()
	return result.([]*models.AssetFolder), err
}

func (a assetFolderDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*models.AssetFolder, err error) {
	buf := make([]*models.AssetFolder, 0, batchSize)
	err = a.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (a assetFolderDo) FindInBatches(result *[]*models.AssetFolder, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return a.DO.FindInBatches(result, batchSize, fc)
}

func (a assetFolderDo) Attrs(attrs ...field.AssignExpr) IAssetFolderDo {
	return a.withDO(a.DO.Attrs(attrs...))
}

func (a assetFolderDo) Assign(attrs ...field.AssignExpr) IAssetFolderDo {
	return a.withDO(a.DO.Assign(attrs...))
}

func (a assetFolderDo) Joins(fields ...field.RelationField) IAssetFolderDo {
	for _, _f := range fields {
		a = *a.withDO(a.DO.Joins(_f))
	}
	return &a
}

func (a assetFolderDo) Preload(fields ...field.RelationField) IAssetFolderDo {
	for _, _f := range fields {
		a = *a.withDO(a.DO.Preload(_f))
	}
	return &a
}

func (a assetFolderDo) FirstOrInit() (*models.AssetFolder, error) {
	if result, err := a.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*models.AssetFolder), nil
	}
}

func (a assetFolderDo) FirstOrCreate() (*models.AssetFolder, error) {
	if result, err := a.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*models.AssetFolder), nil
	}
}

func (a assetFolderDo) FindByPage(offset int, limit int) (result []*models.AssetFolder, count int64, err error) {
	result, err = a.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = a.Offset(-1).Limit(-1).Count()
	return
}

func (a assetFolderDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = a.Count()
	if err != nil {
		return
	}

	err = a.Offset(offset).Limit(limit).Scan(result)
	return
}

func (a assetFolderDo) Scan(result interface{}) (err error) {
	return a.DO.Scan(result)
}

func (a assetFolderDo) Delete(models ...*models.AssetFolder) (result gen.ResultInfo, err error) {
	return a.DO.Delete(models)
}

func (a *assetFolderDo) withDO(do gen.Dao) *assetFolderDo {
	a.DO = *do.(*gen.DO)
	return a
}
